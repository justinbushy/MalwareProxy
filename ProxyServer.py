'''
Justin Bush
u0701867

Programming Assignment 1 (PA1)
CS4480 - Spring 2017

'''

from socket import *
from sys import argv
import sys
import threading
from BaseHTTPServer import BaseHTTPRequestHandler
from StringIO import StringIO
import hashlib

#################################################
#This method parses the request string accordingly
#If request is not a GET, send back 501 Not Implemented
#################################################
def check_request(req):
	host = ""
	path = ""
	headers = ""

	par_req = requestchecker(req)

	#use BaseHTTPRequestHandler to check for errors in HTTP Request
	if(par_req.error_code != None):
		ret_http = "HTTP/1.0 " + str(par_req.error_code) + " " + par_req.error_message + "\r\n\r\n"
		return ret_http, host

	#split request string by carriage return for parsing
	car_sp = req.split('\r\n')

	sp_req_list = req.split()
	if(len(sp_req_list) > 0 and sp_req_list[0] == "GET"):
		url_sp = sp_req_list[1].split('/')
		start = 1;	
		if(url_sp[0] == "http:"):
			host = url_sp[2]
			if(host == ""):
				ret_http = "HTTP/1.0 400 Bad Request\r\n\r\n"
				return ret_http, host
			start = 3
		else:
			host = url_sp[0]
		for num in range(start, len(url_sp)):
			path += "/" + url_sp[num]

		for num in range(1, len(car_sp)):
			if(len(car_sp[num].split()) > 0):
				
				if(car_sp[num].split()[0] == "Connection:"):
					headers += "Connection: close\r\n" # keep-alive => close
				elif(car_sp[num].split()[0] == "Host:"):
					host = car_sp[num].split()[1]
				elif(car_sp[num].split()[0] == "Content-encoding:"):
					print "content encoding"
					headers += "Content-encoding: identity"
				else:
					headers += car_sp[num] + "\r\n"

		# build correct GET request with appropriate headers
		ret_http = "GET " + path + " HTTP/1.0\r\nHost: " + host + "\r\n" + headers + "\r\n\r\n"
		return ret_http, host
	else:
		ret_http = "HTTP/1.0 501 Not Implemented\r\n\r\n"
		return ret_http, host

#############################################
#class used from stackoverflow: http://stackoverflow.com/questions/4685217/parse-raw-http-headers
#############################################
class requestchecker(BaseHTTPRequestHandler):
	def __init__(self, request):
		self.rfile = StringIO(request)
		self.raw_requestline = self.rfile.readline()
		self.error_code = self.error_message = None
		self.parse_request()

	def send_error(self, code, message):
		self.error_code = code
		self.error_message = message

###########################################
#This method parses the response and sends body to Team Cymru
#
#Reports True if containing malware
#Reporst False if not
########################################
def checkWithCymru(response):
	
	sp = response.split("\r\n")
	body = ""

	#parse response to retreive just body
	for num in range(0, len(sp)):
		if(sp[num] == ""):
			for n in range(num+1, len(sp)-1):
					body += sp[n] + "\r\n"
			body += sp[len(sp)-1]
			break
	
	cSocket = socket(AF_INET, SOCK_STREAM)
	cSocket.connect(("hash.cymru.com", 43))

	#create md5 hash
	mhash = hashlib.md5()
	mhash.update(body)

	hashRequest = "%s\r\n\r\n" % mhash.hexdigest()
	
	cSocket.send(hashRequest)
	returnResponse = ""
	while True:
		backSentence = cSocket.recv(1024)
		if not backSentence: break
		returnResponse += backSentence

	cSocket.close()

	if 'NO_DATA' in returnResponse:
		return False
	else:
		return True


#############################################
#This method processes client requests. Should be called to start a thread. 
#Once a request comes in, this method calls another method to parse the request. 
#It then receives the response from the remote server. 
#With the response, it creats an md5 hash and checks that with Team Cymru.
#It then reports if it was malware to client or just sends response through.
# 
#Uses malware.html
############################################

def process_client(client, address):
	clientRequest = ""	
	# keep receiving until "\r\n\r\n" is received
	while True:
		sentence = client.recv(1024)
		clientRequest += sentence
		if "\r\n\r\n" in clientRequest or sentence == "": break
			
	if(clientRequest != ""):
		# get corrected HTTP request and host from check_request()	
		http, host = check_request(clientRequest)
		if(len(clientRequest.split()) > 1):
			nextServerName = clientRequest.split()[1]
		
		# attempt to send GET request
		if(http.split()[0] == "GET"):
			clientSocket = socket(AF_INET, SOCK_STREAM)
			if not remoteServerPort:
				clientSocket.connect((host, 80))
			else:
				clientSocket.connect((host, remoteServerPort))
			sp = http.split()
		
			clientSocket.send(http)
			returnSentence = ""
			backSentence = clientSocket.recv(1024)
			returnSentence += backSentence

			# receive whole response
			while True:
				backSentence = clientSocket.recv(1024)
				if not backSentence: break
				returnSentence += backSentence
			clientSocket.close()

			#check with team cymru
			containsMalware = checkWithCymru(returnSentence)

			if (containsMalware == False):
				client.send(returnSentence);
			else:
				try:	
					f = open("warning.html", "r")
					malwareResponse = f.read(1024)
					while(malwareResponse):
						client.send(malwareResponse)
						malwareResponse = f.read(1024)
				except:
					malwareResponse = "HTTP/1.0 200 OK\r\n<!DOCTYPE html><html><body><h1>Content was blocked because it is suspected of malware.</h1></body></html>\r\n\r\n" 
					client.send(malwareResponse)

			client.close()
		else:
			client.send(http)
			client.close()

###### ENTRY POINT TO APPLICATION ######

# get input from command line
argLen = len(argv)
if(argLen > 1):
	proxyPort = int(argv[1])
else:
	proxyPort = 2117
	print "No proxy port given --- default set to 2117"
remoteServerPort = ""
if(argLen == 3):
	remoteServerPort = int(argv[2])

#create socket on port specified in command line 
serverSocket = socket(AF_INET, SOCK_STREAM)
serverSocket.bind(('', proxyPort))
serverSocket.listen(1)

print('The server is ready to receive')

while True:
	connectionSocket, addr = serverSocket.accept()
	t = threading.Thread(target = process_client, args = (connectionSocket, addr))
	t.setDaemon(True)
	t.start()

connectionSocket.close()
serverSocket.close()


